<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.8.12"/>
        <title>ZED SDK: Mat Class Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito:400,500,800">
        <link href="stylesheet.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div id="titlearea">
                <table cellspacing="0" cellpadding="0">
                    <tbody>
                        <tr style="height: 56px;">
                            <td id="projectlogo" >
                                <a href="https://www.stereolabs.com/"> <img alt="Logo" src="logo_stereolabs.png" height="27"/> </a>
                            </td>
                            <td style="padding-left: 0.4cm;">
                                <div id="projectname"><!--ZED SDK-->
                                    <span id="projectnumber"> | ZED SDK 2.1.2</span>
                                </div>
                                <!--BEGIN PROJECT_BRIEF<div id="projectbrief"></div><!--END PROJECT_BRIEF-->
                            </td>
                            <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classsl_1_1Mat.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsl_1_1Mat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mat Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> class can handle multiple matrix format from 1 to 4 channels, with different value types (float or uchar), and can be stored CPU and/or GPU side.  
 <a href="classsl_1_1Mat.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e4639b574685e1d9162ed953e607ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a13e4639b574685e1d9162ed953e607ed">Mat</a> ()</td></tr>
<tr class="memdesc:a13e4639b574685e1d9162ed953e607ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> default constructor.  <a href="#a13e4639b574685e1d9162ed953e607ed">More...</a><br /></td></tr>
<tr class="separator:a13e4639b574685e1d9162ed953e607ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad430a928c3b9036f27963d2408602749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#ad430a928c3b9036f27963d2408602749">Mat</a> (size_t width, size_t height, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:ad430a928c3b9036f27963d2408602749"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor.  <a href="#ad430a928c3b9036f27963d2408602749">More...</a><br /></td></tr>
<tr class="separator:ad430a928c3b9036f27963d2408602749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4c88b51cfa492f0d0acb4055e53803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a3e4c88b51cfa492f0d0acb4055e53803">Mat</a> (size_t width, size_t height, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *ptr, size_t step, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:a3e4c88b51cfa492f0d0acb4055e53803"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer.  <a href="#a3e4c88b51cfa492f0d0acb4055e53803">More...</a><br /></td></tr>
<tr class="separator:a3e4c88b51cfa492f0d0acb4055e53803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e41f91b8f918baed38d25da9ea63c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a577e41f91b8f918baed38d25da9ea63c">Mat</a> (size_t width, size_t height, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *ptr_cpu, size_t step_cpu, <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *ptr_gpu, size_t step_gpu)</td></tr>
<tr class="memdesc:a577e41f91b8f918baed38d25da9ea63c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU.  <a href="#a577e41f91b8f918baed38d25da9ea63c">More...</a><br /></td></tr>
<tr class="separator:a577e41f91b8f918baed38d25da9ea63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ea3f154ef776e53bf6afec905327a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a413ea3f154ef776e53bf6afec905327a">Mat</a> (<a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a> resolution, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:a413ea3f154ef776e53bf6afec905327a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor.  <a href="#a413ea3f154ef776e53bf6afec905327a">More...</a><br /></td></tr>
<tr class="separator:a413ea3f154ef776e53bf6afec905327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b889acf09ca25035b6e7fba91c083c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a50b889acf09ca25035b6e7fba91c083c">Mat</a> (<a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a> resolution, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *ptr, size_t step, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:a50b889acf09ca25035b6e7fba91c083c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer.  <a href="#a50b889acf09ca25035b6e7fba91c083c">More...</a><br /></td></tr>
<tr class="separator:a50b889acf09ca25035b6e7fba91c083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357f076460a85a02e4b314c812bddd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#ae357f076460a85a02e4b314c812bddd1">Mat</a> (<a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a> resolution, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *ptr_cpu, size_t step_cpu, <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *ptr_gpu, size_t step_gpu)</td></tr>
<tr class="memdesc:ae357f076460a85a02e4b314c812bddd1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU.  <a href="#ae357f076460a85a02e4b314c812bddd1">More...</a><br /></td></tr>
<tr class="separator:ae357f076460a85a02e4b314c812bddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a9abbeab47a716e9103f2ce5d9a6d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#aa0a9abbeab47a716e9103f2ce5d9a6d6">Mat</a> (const <a class="el" href="classsl_1_1Mat.html">sl::Mat</a> &amp;mat)</td></tr>
<tr class="memdesc:aa0a9abbeab47a716e9103f2ce5d9a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor by copy (deep copy).  <a href="#aa0a9abbeab47a716e9103f2ce5d9a6d6">More...</a><br /></td></tr>
<tr class="separator:aa0a9abbeab47a716e9103f2ce5d9a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758f0735ff6b2111adda36d7289d08b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a758f0735ff6b2111adda36d7289d08b4">alloc</a> (size_t width, size_t height, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:a758f0735ff6b2111adda36d7289d08b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory.  <a href="#a758f0735ff6b2111adda36d7289d08b4">More...</a><br /></td></tr>
<tr class="separator:a758f0735ff6b2111adda36d7289d08b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82043e1f972dd11911bec6c258a3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#aeb82043e1f972dd11911bec6c258a3ee">alloc</a> (<a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a> resolution, <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> mat_type, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:aeb82043e1f972dd11911bec6c258a3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory.  <a href="#aeb82043e1f972dd11911bec6c258a3ee">More...</a><br /></td></tr>
<tr class="separator:aeb82043e1f972dd11911bec6c258a3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85825bed2f9a04a95dcee2b84d96fd5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a85825bed2f9a04a95dcee2b84d96fd5e">~Mat</a> ()</td></tr>
<tr class="memdesc:a85825bed2f9a04a95dcee2b84d96fd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> destructor. This function calls <a class="el" href="classsl_1_1Mat.html#a55a46a4da55dbe0d01bf21b8b0792280" title="Free the owned memory. ">Mat::free</a> to release owned memory.  <a href="#a85825bed2f9a04a95dcee2b84d96fd5e">More...</a><br /></td></tr>
<tr class="separator:a85825bed2f9a04a95dcee2b84d96fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a46a4da55dbe0d01bf21b8b0792280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a55a46a4da55dbe0d01bf21b8b0792280">free</a> (<a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>|<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">MEM_GPU</a>)</td></tr>
<tr class="memdesc:a55a46a4da55dbe0d01bf21b8b0792280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the owned memory.  <a href="#a55a46a4da55dbe0d01bf21b8b0792280">More...</a><br /></td></tr>
<tr class="separator:a55a46a4da55dbe0d01bf21b8b0792280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dbb18591a2dcba489f153dfe7d893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#af35dbb18591a2dcba489f153dfe7d893">operator=</a> (const <a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;that)</td></tr>
<tr class="memdesc:af35dbb18591a2dcba489f153dfe7d893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a shallow copy. <br />
 This function doesn't copy the data array, it only copies the pointer.  <a href="#af35dbb18591a2dcba489f153dfe7d893">More...</a><br /></td></tr>
<tr class="separator:af35dbb18591a2dcba489f153dfe7d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61db709e04e1cd353b852514d280a99f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a61db709e04e1cd353b852514d280a99f">updateCPUfromGPU</a> ()</td></tr>
<tr class="memdesc:a61db709e04e1cd353b852514d280a99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downloads data from DEVICE (GPU) to HOST (CPU), if possible.  <a href="#a61db709e04e1cd353b852514d280a99f">More...</a><br /></td></tr>
<tr class="separator:a61db709e04e1cd353b852514d280a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6aadc30f3bc8df5e99850ff7e6cc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#afa6aadc30f3bc8df5e99850ff7e6cc4b">updateGPUfromCPU</a> ()</td></tr>
<tr class="memdesc:afa6aadc30f3bc8df5e99850ff7e6cc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads data from HOST (CPU) to DEVICE (GPU), if possible.  <a href="#afa6aadc30f3bc8df5e99850ff7e6cc4b">More...</a><br /></td></tr>
<tr class="separator:afa6aadc30f3bc8df5e99850ff7e6cc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a8fd8d9763ffc498c903da4a1b411d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#ae8a8fd8d9763ffc498c903da4a1b411d">copyTo</a> (<a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;dst, <a class="el" href="group__Enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a> cpyType=<a class="el" href="namespacesl.html#ga6053bda451d8ca289b3e443377cfc004a8c3304634b47d86cefb6480d7fbbdcf4">COPY_TYPE_CPU_CPU</a>) const</td></tr>
<tr class="memdesc:ae8a8fd8d9763ffc498c903da4a1b411d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data an other <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy).  <a href="#ae8a8fd8d9763ffc498c903da4a1b411d">More...</a><br /></td></tr>
<tr class="separator:ae8a8fd8d9763ffc498c903da4a1b411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb25ebe04ae0193f13d34a77089b6b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#aeb25ebe04ae0193f13d34a77089b6b04">setFrom</a> (const <a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;src, <a class="el" href="group__Enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a> cpyType=<a class="el" href="namespacesl.html#ga6053bda451d8ca289b3e443377cfc004a8c3304634b47d86cefb6480d7fbbdcf4">COPY_TYPE_CPU_CPU</a>)</td></tr>
<tr class="memdesc:aeb25ebe04ae0193f13d34a77089b6b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from an other <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy).  <a href="#aeb25ebe04ae0193f13d34a77089b6b04">More...</a><br /></td></tr>
<tr class="separator:aeb25ebe04ae0193f13d34a77089b6b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ea6ea6124438c6652336d357bffec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a863ea6ea6124438c6652336d357bffec">read</a> (const char *filePath)</td></tr>
<tr class="memdesc:a863ea6ea6124438c6652336d357bffec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an image from a file (only if <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> is available on the current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a>).  <a href="#a863ea6ea6124438c6652336d357bffec">More...</a><br /></td></tr>
<tr class="separator:a863ea6ea6124438c6652336d357bffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acf6247c440dcd777d3da7e55bee2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a7acf6247c440dcd777d3da7e55bee2fd">write</a> (const char *filePath)</td></tr>
<tr class="memdesc:a7acf6247c440dcd777d3da7e55bee2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> (only if <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> is available) into a file as an image.  <a href="#a7acf6247c440dcd777d3da7e55bee2fd">More...</a><br /></td></tr>
<tr class="separator:a7acf6247c440dcd777d3da7e55bee2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af000d3beacf03312363f52b1d8825ccc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af000d3beacf03312363f52b1d8825ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#af000d3beacf03312363f52b1d8825ccc">setTo</a> (T value, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:af000d3beacf03312363f52b1d8825ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> with the given value.  <a href="#af000d3beacf03312363f52b1d8825ccc">More...</a><br /></td></tr>
<tr class="separator:af000d3beacf03312363f52b1d8825ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fb42724066753c016b9b86145da01f"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a79fb42724066753c016b9b86145da01f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a79fb42724066753c016b9b86145da01f">setValue</a> (size_t x, size_t y, N value, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>)</td></tr>
<tr class="memdesc:a79fb42724066753c016b9b86145da01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a value to a specific point in the matrix.  <a href="#a79fb42724066753c016b9b86145da01f">More...</a><br /></td></tr>
<tr class="separator:a79fb42724066753c016b9b86145da01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7283ff22eb1739bcf32d83d02ed7f181"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a7283ff22eb1739bcf32d83d02ed7f181"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a7283ff22eb1739bcf32d83d02ed7f181">getValue</a> (size_t x, size_t y, N *value, <a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>) const</td></tr>
<tr class="memdesc:a7283ff22eb1739bcf32d83d02ed7f181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a specific point in the matrix.  <a href="#a7283ff22eb1739bcf32d83d02ed7f181">More...</a><br /></td></tr>
<tr class="separator:a7283ff22eb1739bcf32d83d02ed7f181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52477d2dcc839fafe8a8ee5026a2621"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#aa52477d2dcc839fafe8a8ee5026a2621">getWidth</a> () const</td></tr>
<tr class="separator:aa52477d2dcc839fafe8a8ee5026a2621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb56064ac644b85442a915c9fdf19f8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#afdb56064ac644b85442a915c9fdf19f8">getHeight</a> () const</td></tr>
<tr class="separator:afdb56064ac644b85442a915c9fdf19f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2095803fee1da82ac47fc910093d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsl_1_1Resolution.html">Resolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a9e2095803fee1da82ac47fc910093d06">getResolution</a> () const</td></tr>
<tr class="separator:a9e2095803fee1da82ac47fc910093d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a98e29bec33645a8136249a89ec641"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a90a98e29bec33645a8136249a89ec641">getChannels</a> () const</td></tr>
<tr class="separator:a90a98e29bec33645a8136249a89ec641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6673fd67d68f40f36677ed6945aa25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a1b6673fd67d68f40f36677ed6945aa25">getDataType</a> () const</td></tr>
<tr class="separator:a1b6673fd67d68f40f36677ed6945aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91472e3702165e932795750d0951c3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a91472e3702165e932795750d0951c3b0">getMemoryType</a> () const</td></tr>
<tr class="separator:a91472e3702165e932795750d0951c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1bf1f7c5b564284bf901880e33adcd"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a6c1bf1f7c5b564284bf901880e33adcd"><td class="memTemplItemLeft" align="right" valign="top">N *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a6c1bf1f7c5b564284bf901880e33adcd">getPtr</a> (<a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>) const</td></tr>
<tr class="separator:a6c1bf1f7c5b564284bf901880e33adcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983b4c21e575a59322710aec3a3a555c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a983b4c21e575a59322710aec3a3a555c">getStepBytes</a> (<a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>) const</td></tr>
<tr class="separator:a983b4c21e575a59322710aec3a3a555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be14f373804560ff589db811163214a"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a3be14f373804560ff589db811163214a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a3be14f373804560ff589db811163214a">getStep</a> (<a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>) const</td></tr>
<tr class="separator:a3be14f373804560ff589db811163214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad791edb5be171d5cf0d7f990c7516376"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#ad791edb5be171d5cf0d7f990c7516376">getStep</a> (<a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> memory_type=<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>) const</td></tr>
<tr class="separator:ad791edb5be171d5cf0d7f990c7516376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730a74cc75f66f213804b8b9d2365939"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a730a74cc75f66f213804b8b9d2365939">getPixelBytes</a> () const</td></tr>
<tr class="separator:a730a74cc75f66f213804b8b9d2365939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4429863e476cebb9936573514d1f6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a3c4429863e476cebb9936573514d1f6f">getWidthBytes</a> () const</td></tr>
<tr class="separator:a3c4429863e476cebb9936573514d1f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfac867c035e4e665327c72d75b41ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsl_1_1String.html">sl::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a9cfac867c035e4e665327c72d75b41ce">getInfos</a> ()</td></tr>
<tr class="separator:a9cfac867c035e4e665327c72d75b41ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6940875839b3ed8f7e425dd7ea6a51d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a6940875839b3ed8f7e425dd7ea6a51d5">isInit</a> () const</td></tr>
<tr class="separator:a6940875839b3ed8f7e425dd7ea6a51d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ae510e34fb6dbb561efe4fbe35934"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a277ae510e34fb6dbb561efe4fbe35934">isMemoryOwner</a> () const</td></tr>
<tr class="separator:a277ae510e34fb6dbb561efe4fbe35934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6801c0ecd6cb3e4844a83a7299feb2dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a6801c0ecd6cb3e4844a83a7299feb2dd">clone</a> (const <a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;src)</td></tr>
<tr class="memdesc:a6801c0ecd6cb3e4844a83a7299feb2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> by copy (deep copy).  <a href="#a6801c0ecd6cb3e4844a83a7299feb2dd">More...</a><br /></td></tr>
<tr class="separator:a6801c0ecd6cb3e4844a83a7299feb2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343c68731bcccfce8c862d2573733b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a343c68731bcccfce8c862d2573733b80">move</a> (<a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;dst)</td></tr>
<tr class="memdesc:a343c68731bcccfce8c862d2573733b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> data to another <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>.  <a href="#a343c68731bcccfce8c862d2573733b80">More...</a><br /></td></tr>
<tr class="separator:a343c68731bcccfce8c862d2573733b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3d005d4494e00097cedc5c04db582c12"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#a3d005d4494e00097cedc5c04db582c12">swap</a> (<a class="el" href="classsl_1_1Mat.html">sl::Mat</a> &amp;mat1, <a class="el" href="classsl_1_1Mat.html">sl::Mat</a> &amp;mat2)</td></tr>
<tr class="memdesc:a3d005d4494e00097cedc5c04db582c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of the provided <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (only swaps the pointers, no data copy).  <a href="#a3d005d4494e00097cedc5c04db582c12">More...</a><br /></td></tr>
<tr class="separator:a3d005d4494e00097cedc5c04db582c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae91eebfb22e45be6b4ceee466f3d5a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsl_1_1String.html">sl::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#ae91eebfb22e45be6b4ceee466f3d5a16">name</a></td></tr>
<tr class="separator:ae91eebfb22e45be6b4ceee466f3d5a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f078684998b83967d507d0f453f454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1Mat.html#ab3f078684998b83967d507d0f453f454">verbose</a> = false</td></tr>
<tr class="separator:ab3f078684998b83967d507d0f453f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> class can handle multiple matrix format from 1 to 4 channels, with different value types (float or uchar), and can be stored CPU and/or GPU side. </p>
<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> is defined in a row-major order, it means that, for an image buffer, the entire first row is stored first, followed by the entire second row, and so on.</p>
<p>The CPU and GPU buffer aren't automatically synchronized for performance reasons, you can use <a class="el" href="classsl_1_1Mat.html#a61db709e04e1cd353b852514d280a99f" title="Downloads data from DEVICE (GPU) to HOST (CPU), if possible. ">Mat::updateCPUfromGPU</a> / <a class="el" href="classsl_1_1Mat.html#afa6aadc30f3bc8df5e99850ff7e6cc4b" title="Uploads data from HOST (CPU) to DEVICE (GPU), if possible. ">Mat::updateGPUfromCPU</a> to do it. If you are using the GPU side of the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> object, you need to make sure to call <a class="el" href="classsl_1_1Mat.html#a55a46a4da55dbe0d01bf21b8b0792280" title="Free the owned memory. ">sl::Mat::free()</a> before destroying the <a class="el" href="classsl_1_1Camera.html" title="The main class to use the ZED camera. ">sl::Camera</a> object. The destruction of the <a class="el" href="classsl_1_1Camera.html" title="The main class to use the ZED camera. ">sl::Camera</a> object delete the CUDA context needed to free the GPU <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a13e4639b574685e1d9162ed953e607ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e4639b574685e1d9162ed953e607ed">&sect;&nbsp;</a></span>Mat() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>empty <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> default constructor. </p>

</div>
</div>
<a id="ad430a928c3b9036f27963d2408602749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad430a928c3b9036f27963d2408602749">&sect;&nbsp;</a></span>Mat() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>). This function directly allocates the requested memory. It calls <a class="el" href="classsl_1_1Mat.html#a758f0735ff6b2111adda36d7289d08b4" title="Allocates the Mat memory. ">Mat::alloc</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e4c88b51cfa492f0d0acb4055e53803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4c88b51cfa492f0d0acb4055e53803">&sect;&nbsp;</a></span>Mat() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">ptr</td><td>: pointer to the data array. (CPU or GPU). </td></tr>
    <tr><td class="paramname">step</td><td>: step of the data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>). This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a577e41f91b8f918baed38d25da9ea63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e41f91b8f918baed38d25da9ea63c">&sect;&nbsp;</a></span>Mat() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *&#160;</td>
          <td class="paramname"><em>ptr_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *&#160;</td>
          <td class="paramname"><em>ptr_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_gpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">ptr_cpu</td><td>: CPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_cpu</td><td>: step of the CPU data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">ptr_gpu</td><td>: GPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_gpu</td><td>: step of the GPU data array. (the Bytes size of one pixel row) This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413ea3f154ef776e53bf6afec905327a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ea3f154ef776e53bf6afec905327a">&sect;&nbsp;</a></span>Mat() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>). This function directly allocates the requested memory. It calls <a class="el" href="classsl_1_1Mat.html#a758f0735ff6b2111adda36d7289d08b4" title="Allocates the Mat memory. ">Mat::alloc</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50b889acf09ca25035b6e7fba91c083c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b889acf09ca25035b6e7fba91c083c">&sect;&nbsp;</a></span>Mat() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from an existing data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">ptr</td><td>: pointer to the data array. (CPU or GPU). </td></tr>
    <tr><td class="paramname">step</td><td>: step of the data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>). This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae357f076460a85a02e4b314c812bddd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357f076460a85a02e4b314c812bddd1">&sect;&nbsp;</a></span>Mat() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *&#160;</td>
          <td class="paramname"><em>ptr_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a> *&#160;</td>
          <td class="paramname"><em>ptr_gpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step_gpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor from two existing data pointers, CPU and GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">ptr_cpu</td><td>: CPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_cpu</td><td>: step of the CPU data array. (the Bytes size of one pixel row) </td></tr>
    <tr><td class="paramname">ptr_gpu</td><td>: GPU pointer to the data array. </td></tr>
    <tr><td class="paramname">step_gpu</td><td>: step of the GPU data array. (the Bytes size of one pixel row) This function doesn't allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a9abbeab47a716e9103f2ce5d9a6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a9abbeab47a716e9103f2ce5d9a6d6">&sect;&nbsp;</a></span>Mat() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1Mat.html">sl::Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> constructor by copy (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>: the reference to the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> to copy. This function allocates and duplicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85825bed2f9a04a95dcee2b84d96fd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85825bed2f9a04a95dcee2b84d96fd5e">&sect;&nbsp;</a></span>~Mat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classsl_1_1Mat.html">Mat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> destructor. This function calls <a class="el" href="classsl_1_1Mat.html#a55a46a4da55dbe0d01bf21b8b0792280" title="Free the owned memory. ">Mat::free</a> to release owned memory. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a758f0735ff6b2111adda36d7289d08b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758f0735ff6b2111adda36d7289d08b4">&sect;&nbsp;</a></span>alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>: width of the matrix in pixels </td></tr>
    <tr><td class="paramname">height</td><td>: height of the matrix in pixels </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It erases previously allocated memory. </dd></dl>

</div>
</div>
<a id="aeb82043e1f972dd11911bec6c258a3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb82043e1f972dd11911bec6c258a3ee">&sect;&nbsp;</a></span>alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1Resolution.html">sl::Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a>&#160;</td>
          <td class="paramname"><em>mat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>: the size of the matrix in pixels. </td></tr>
    <tr><td class="paramname">mat_type</td><td>: the type of the matrix (<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a35e58e91cfcc801808b2f7d5349b64d3">sl::MAT_TYPE_32F_C1</a>,<a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>...) </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines where the buffer will be stored. (<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It erases previously allocated memory. </dd></dl>

</div>
</div>
<a id="a55a46a4da55dbe0d01bf21b8b0792280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a46a4da55dbe0d01bf21b8b0792280">&sect;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a>|<a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">MEM_GPU</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the owned memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want to free the <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> and/or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a> memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af35dbb18591a2dcba489f153dfe7d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35dbb18591a2dcba489f153dfe7d893">&sect;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1Mat.html">Mat</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a shallow copy. <br />
 This function doesn't copy the data array, it only copies the pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>: the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> object which point to the same data as that. </dd></dl>

</div>
</div>
<a id="a61db709e04e1cd353b852514d280a99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61db709e04e1cd353b852514d280a99f">&sect;&nbsp;</a></span>updateCPUfromGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> updateCPUfromGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downloads data from DEVICE (GPU) to HOST (CPU), if possible. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no CPU or GPU memory are available for this <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>, some are directly allocated. </dd>
<dd>
If verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="afa6aadc30f3bc8df5e99850ff7e6cc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6aadc30f3bc8df5e99850ff7e6cc4b">&sect;&nbsp;</a></span>updateGPUfromCPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> updateGPUfromCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads data from HOST (CPU) to DEVICE (GPU), if possible. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no CPU or GPU memory are available for this <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>, some are directly allocated. </dd>
<dd>
If verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="ae8a8fd8d9763ffc498c903da4a1b411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a8fd8d9763ffc498c903da4a1b411d">&sect;&nbsp;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a>&#160;</td>
          <td class="paramname"><em>cpyType</em> = <code><a class="el" href="namespacesl.html#ga6053bda451d8ca289b3e443377cfc004a8c3304634b47d86cefb6480d7fbbdcf4">COPY_TYPE_CPU_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data an other <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>: the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> where the data will be copied. </td></tr>
    <tr><td class="paramname">cpyType</td><td>: specify the memories that will be used for the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the destination is not allocated or has a not a compatible <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713" title="List available Mat formats. ">sl::MAT_TYPE</a> or <a class="el" href="structsl_1_1Resolution.html" title="Width and height of an array. ">sl::Resolution</a>, current memory is freed and new memory is directly allocated. </dd></dl>

</div>
</div>
<a id="aeb25ebe04ae0193f13d34a77089b6b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb25ebe04ae0193f13d34a77089b6b04">&sect;&nbsp;</a></span>setFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> setFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga6053bda451d8ca289b3e443377cfc004">COPY_TYPE</a>&#160;</td>
          <td class="paramname"><em>cpyType</em> = <code><a class="el" href="namespacesl.html#ga6053bda451d8ca289b3e443377cfc004a8c3304634b47d86cefb6480d7fbbdcf4">COPY_TYPE_CPU_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from an other <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>: the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> where the data will be copied from. </td></tr>
    <tr><td class="paramname">cpyType</td><td>: specify the memories that will be used for the update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is not allocated or has a not a compatible <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713" title="List available Mat formats. ">sl::MAT_TYPE</a> or <a class="el" href="structsl_1_1Resolution.html" title="Width and height of an array. ">sl::Resolution</a> with the source, current memory is freed and new memory is directly allocated. </dd></dl>

</div>
</div>
<a id="a863ea6ea6124438c6652336d357bffec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ea6ea6124438c6652336d357bffec">&sect;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> read </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an image from a file (only if <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> is available on the current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>: file path including the name and extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supported <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713" title="List available Mat formats. ">sl::MAT_TYPE</a> are : <a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a7d0a7977056c8a9b82a43dc36756c48b">sl::MAT_TYPE_8U_C1</a>, <a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a1e4ab6d5addb30d2e5dd4cf2e7c5e4c2">sl::MAT_TYPE_8U_C3</a> and <a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>.  input files format are PNG and JPEG.  verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="a7acf6247c440dcd777d3da7e55bee2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acf6247c440dcd777d3da7e55bee2fd">&sect;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">sl::Mat</a> (only if <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> is available) into a file as an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>: file path including the name and extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supported <a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713" title="List available Mat formats. ">sl::MAT_TYPE</a> are : <a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a7d0a7977056c8a9b82a43dc36756c48b">sl::MAT_TYPE_8U_C1</a>, <a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a1e4ab6d5addb30d2e5dd4cf2e7c5e4c2">sl::MAT_TYPE_8U_C3</a> and <a class="el" href="namespacesl.html#gab12e66b9515d6772cda59cc2f7e69713a36e531768171994dc4167a07c774b6e1">sl::MAT_TYPE_8U_C4</a>.  output files format are PNG and JPEG.  verbose sets, you have informations in case of failure. </dd></dl>

</div>
</div>
<a id="af000d3beacf03312363f52b1d8825ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af000d3beacf03312363f52b1d8825ccc">&sect;&nbsp;</a></span>setTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> setTo </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>: the value to be copied all over the matrix. </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines which buffer to fill, CPU and/or GPU. This function overwrite all the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated for <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a>, <a class="el" href="namespacesl.html#aef35ad58b14f5a7c90dcce68c2e40d14">sl::uchar2</a>, <a class="el" href="namespacesl.html#aa040a81651d2f9f6ec43606f1e078ab7">sl::uchar3</a>, <a class="el" href="namespacesl.html#a85805eae6c9f6a74bce0ff93bb4aa7ca">sl::uchar4</a>, <a class="el" href="namespacesl.html#af5208d01f6c6fbcb7bb55d610b9c0ead">sl::float1</a>, <a class="el" href="namespacesl.html#a5b6044bb25c1ea557c70b0110089a075">sl::float2</a>, <a class="el" href="namespacesl.html#aa21e242f2d030e0f1878f8a5854c35e2">sl::float3</a>, <a class="el" href="namespacesl.html#ac3eaabd86b6924fdaa4bacecc2a10d4c">sl::float4</a>. </dd></dl>

</div>
</div>
<a id="a79fb42724066753c016b9b86145da01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fb42724066753c016b9b86145da01f">&sect;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> setValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a value to a specific point in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: specify the column. </td></tr>
    <tr><td class="paramname">y</td><td>: specify the row. </td></tr>
    <tr><td class="paramname">value</td><td>: the value to be set. </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines which memory will be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not efficient for <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>, use it on sparse data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated for <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a>, <a class="el" href="namespacesl.html#aef35ad58b14f5a7c90dcce68c2e40d14">sl::uchar2</a>, <a class="el" href="namespacesl.html#aa040a81651d2f9f6ec43606f1e078ab7">sl::uchar3</a>, <a class="el" href="namespacesl.html#a85805eae6c9f6a74bce0ff93bb4aa7ca">sl::uchar4</a>, <a class="el" href="namespacesl.html#af5208d01f6c6fbcb7bb55d610b9c0ead">sl::float1</a>, <a class="el" href="namespacesl.html#a5b6044bb25c1ea557c70b0110089a075">sl::float2</a>, <a class="el" href="namespacesl.html#aa21e242f2d030e0f1878f8a5854c35e2">sl::float3</a>, <a class="el" href="namespacesl.html#ac3eaabd86b6924fdaa4bacecc2a10d4c">sl::float4</a>. </dd></dl>

</div>
</div>
<a id="a7283ff22eb1739bcf32d83d02ed7f181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7283ff22eb1739bcf32d83d02ed7f181">&sect;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> getValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a specific point in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: specify the column </td></tr>
    <tr><td class="paramname">y</td><td>: specify the row </td></tr>
    <tr><td class="paramname">memory_type</td><td>: defines which memory should be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28cac7f69f7c9e5aea9b8f54cf02870e2bf8">sl::SUCCESS</a> if everything went well, <a class="el" href="namespacesl.html#ga4db9ee29f2ff83c71567c12f6bfbf28ca628cf76228573dbce4b8e971211830ac">sl::ERROR_CODE_FAILURE</a> otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not efficient for <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a>, use it on sparse data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated for <a class="el" href="namespacesl.html#a11c55178eaefe3777614cf5e21accfe7">sl::uchar1</a>, <a class="el" href="namespacesl.html#aef35ad58b14f5a7c90dcce68c2e40d14">sl::uchar2</a>, <a class="el" href="namespacesl.html#aa040a81651d2f9f6ec43606f1e078ab7">sl::uchar3</a>, <a class="el" href="namespacesl.html#a85805eae6c9f6a74bce0ff93bb4aa7ca">sl::uchar4</a>, <a class="el" href="namespacesl.html#af5208d01f6c6fbcb7bb55d610b9c0ead">sl::float1</a>, <a class="el" href="namespacesl.html#a5b6044bb25c1ea557c70b0110089a075">sl::float2</a>, <a class="el" href="namespacesl.html#aa21e242f2d030e0f1878f8a5854c35e2">sl::float3</a>, <a class="el" href="namespacesl.html#ac3eaabd86b6924fdaa4bacecc2a10d4c">sl::float4</a>. </dd></dl>

</div>
</div>
<a id="aa52477d2dcc839fafe8a8ee5026a2621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52477d2dcc839fafe8a8ee5026a2621">&sect;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the width of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The width of the matrix in pixels. </dd></dl>

</div>
</div>
<a id="afdb56064ac644b85442a915c9fdf19f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb56064ac644b85442a915c9fdf19f8">&sect;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the height of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The height of the matrix in pixels. </dd></dl>

</div>
</div>
<a id="a9e2095803fee1da82ac47fc910093d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2095803fee1da82ac47fc910093d06">&sect;&nbsp;</a></span>getResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsl_1_1Resolution.html">Resolution</a> getResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the height of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The height of the matrix in pixels. </dd></dl>

</div>
</div>
<a id="a90a98e29bec33645a8136249a89ec641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a98e29bec33645a8136249a89ec641">&sect;&nbsp;</a></span>getChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the number of values stored in one pixel. </p><dl class="section return"><dt>Returns</dt><dd>The number of values in a pixel. </dd></dl>

</div>
</div>
<a id="a1b6673fd67d68f40f36677ed6945aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6673fd67d68f40f36677ed6945aa25">&sect;&nbsp;</a></span>getDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#gab12e66b9515d6772cda59cc2f7e69713">MAT_TYPE</a> getDataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the format of the matrix. </p><dl class="section return"><dt>Returns</dt><dd>The format of the current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>. </dd></dl>

</div>
</div>
<a id="a91472e3702165e932795750d0951c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91472e3702165e932795750d0951c3b0">&sect;&nbsp;</a></span>getMemoryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a> getMemoryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the type of memory (CPU and/or GPU). </p><dl class="section return"><dt>Returns</dt><dd>The type of allocated memory. </dd></dl>

</div>
</div>
<a id="a6c1bf1f7c5b564284bf901880e33adcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1bf1f7c5b564284bf901880e33adcd">&sect;&nbsp;</a></span>getPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">N* getPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>brief Returns the CPU or GPU data pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a> step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer of the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> data. </dd></dl>

</div>
</div>
<a id="a983b4c21e575a59322710aec3a3a555c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983b4c21e575a59322710aec3a3a555c">&sect;&nbsp;</a></span>getStepBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getStepBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the memory step in Bytes (the Bytes size of one pixel row). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a> step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The step in bytes of the specified memory. </dd></dl>

</div>
</div>
<a id="a3be14f373804560ff589db811163214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be14f373804560ff589db811163214a">&sect;&nbsp;</a></span>getStep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the memory step in number of elements (the number of values in one pixel row). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a> step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The step in number of elements. </dd></dl>

</div>
</div>
<a id="ad791edb5be171d5cf0d7f990c7516376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad791edb5be171d5cf0d7f990c7516376">&sect;&nbsp;</a></span>getStep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Enumerations.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29">MEM</a>&#160;</td>
          <td class="paramname"><em>memory_type</em> = <code><a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">MEM_CPU</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the memory step in number of elements (the number of values in one pixel row). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_type</td><td>: specify whether you want <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a1456f853dfe91d7e5514b7bd79ca3749">sl::MEM_CPU</a> or <a class="el" href="namespacesl.html#ga3fc8f9f9f84fbb0f728fc2cd399ade29a420909434ee9ddba890003391a26bba2">sl::MEM_GPU</a> step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The step in number of elements. </dd></dl>

</div>
</div>
<a id="a730a74cc75f66f213804b8b9d2365939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730a74cc75f66f213804b8b9d2365939">&sect;&nbsp;</a></span>getPixelBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getPixelBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the size in bytes of one pixel. </p><dl class="section return"><dt>Returns</dt><dd>The size in bytes of a pixel. </dd></dl>

</div>
</div>
<a id="a3c4429863e476cebb9936573514d1f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4429863e476cebb9936573514d1f6f">&sect;&nbsp;</a></span>getWidthBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getWidthBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns the size in bytes of a row. </p><dl class="section return"><dt>Returns</dt><dd>The size in bytes of a row. </dd></dl>

</div>
</div>
<a id="a9cfac867c035e4e665327c72d75b41ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfac867c035e4e665327c72d75b41ce">&sect;&nbsp;</a></span>getInfos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1String.html">sl::String</a> getInfos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>brief Return the informations about the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> into a <a class="el" href="classsl_1_1String.html" title="Defines a string. ">sl::String</a>. </p><dl class="section return"><dt>Returns</dt><dd>A string containing the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> informations. </dd></dl>

</div>
</div>
<a id="a6940875839b3ed8f7e425dd7ea6a51d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6940875839b3ed8f7e425dd7ea6a51d5">&sect;&nbsp;</a></span>isInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Defines whether the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is initialized or not. </p><dl class="section return"><dt>Returns</dt><dd>True if current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> has been allocated (by the constructor or therefore). </dd></dl>

</div>
</div>
<a id="a277ae510e34fb6dbb561efe4fbe35934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277ae510e34fb6dbb561efe4fbe35934">&sect;&nbsp;</a></span>isMemoryOwner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isMemoryOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief Returns whether the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is the owner of the memory it access. <br />
 If not, the memory won't be freed if the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is destroyed. </p><dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is owning its memory, else false. </dd></dl>

</div>
</div>
<a id="a6801c0ecd6cb3e4844a83a7299feb2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6801c0ecd6cb3e4844a83a7299feb2dd">&sect;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> by copy (deep copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>: the reference to the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> to copy. This function copies the data array(s), it mark the new <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> as the memory owner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343c68731bcccfce8c862d2573733b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343c68731bcccfce8c862d2573733b80">&sect;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Enumerations.html#ga4db9ee29f2ff83c71567c12f6bfbf28c">ERROR_CODE</a> move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsl_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> data to another <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>: the reference to the <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> to move. This function gives the attribute of the current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> to the specified one. (No copy). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the current <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> is then no more usable since its loose its attributes. </dd></dl>

</div>
</div>
<a id="a3d005d4494e00097cedc5c04db582c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d005d4494e00097cedc5c04db582c12">&sect;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsl_1_1Mat.html">sl::Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsl_1_1Mat.html">sl::Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the content of the provided <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a> (only swaps the pointers, no data copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>: the first mat. </td></tr>
    <tr><td class="paramname">mat2</td><td>: the second mat. This function swaps the pointers of the given <a class="el" href="classsl_1_1Mat.html" title="The Mat class can handle multiple matrix format from 1 to 4 channels, with different value types (flo...">Mat</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae91eebfb22e45be6b4ceee466f3d5a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91eebfb22e45be6b4ceee466f3d5a16">&sect;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsl_1_1String.html">sl::String</a> name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3f078684998b83967d507d0f453f454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f078684998b83967d507d0f453f454">&sect;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool verbose = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
